// Copyright 2023 Intrinsic Innovation LLC

syntax = "proto3";

package intrinsic_proto.fieldbus.ethercat.device_service.v1;

import "intrinsic/assets/proto/field_metadata.proto";
import "intrinsic/assets/proto/v1/resolved_dependency.proto";

option go_package = "intrinsic/icon/fieldbus/ethercat/device_service/v1/device_service_config_go_proto";

// An identifier for the type and version of an EtherCAT bus device.
// A single ESI or device service can define multiple such products or
// revisions, so we need to strictly define the exact type once. Service
// implementations are expected to validate that the provided DeviceIdentifier
// matches the type of the device.
message DeviceIdentifier {
  int32 vendor_id = 1;
  int32 product_code = 2;
  int32 revision = 3;
}

// The device-specific EtherCAT configuration message.
// This mapping will eventually contain the mapping from bus variables to
// hardware interfaces.
message DeviceServiceConfig {
  // Identifies the device at hand.
  DeviceIdentifier device_identifier = 1;
  intrinsic_proto.assets.v1.ResolvedDependency
      esi_bundle = 2 [(intrinsic_proto.assets.field_metadata).dependency = {
    requires: "data://intrinsic_proto.fieldbus.ethercat.device_service.v1.EsiBundle",
  }];

  // List interface mappings that define how device data will be exposed through
  // hardware interfaces.
  repeated InterfaceMapping interface_mappings = 3;

  // Options to configure the behavior of the device service.
  DeviceServiceOptions options = 4;
}

// Options to configure the behavior of the device service.
message DeviceServiceOptions {
  // If true, the service will log detailed information about the variable
  // resolution process for all variables. This is useful for debugging
  // complex ESI files or mapping issues.
  bool enable_variable_resolution_tracing = 1;
}

// A mapping of device data to a hardware interface.
message InterfaceMapping {
  // The interface that the device data maps to.
  // If DeviceData is a composable type, like JointDeviceData, the same
  // interface can be referenced (even from other bus devices).
  Interface interface = 1;
  // The specific functional device data (e.g., Joint metrics, DS402 drive
  // parameters, or I/O signals) that should be exposed through the interface.
  DeviceData device_data = 2;
}

// An interface to map the device data (joint value, ds402 drive parameters,
// I/O signals) to.
// Initially this will just be hardware interfaces, but this will eventually be
// extended to simulation interfaces.
message Interface {
  // Hardware interface name.
  // Required to be unique in the scope of the same fieldbus.
  string interface_name = 1;
}

// A union of all supported device data types.
// The list matches the interfaces provided by the EtherCAT hardware module
// through the individual `BusDevice` implementations.
message DeviceData {
  oneof data {
    JointDeviceData joint_device_data = 1;
    Ds402DeviceData ds402_device_data = 2;
    // More to be added in the future (i.e. ADIO, F/T)
  }
}

// Describes joint device data of a single joint.
// Additional joint data for the complete joint hardware interface may be
// provided by other (or even the same) bus device(s).
message JointDeviceData {
  // Holds the ESI reference to the joint position command variable.
  VariableReference joint_position_command_reference = 1;

  // Holds the ESI reference to the joint position state variable.
  VariableReference joint_position_state_reference = 2;
  // Holds the optional ESI reference to the joint velocity state variable.
  optional VariableReference joint_velocity_state_reference = 3;
  // Holds the optional ESI reference to the joint acceleration state variable.
  optional VariableReference joint_acceleration_state_reference = 4;

  // The joint index.
  // Joint device data is typically compositioned from multiple joint devices
  // into n-dimensional state and command vectors. This index specifies the
  // position of this joint in the kinematic chain from base to tip. Thus, the
  // index needs to be unique across all variables that are composed to the same
  // interfaces.
  // If not provided, order will be determined from the logical bus position.
  optional uint32 joint_index = 5;

  // The scale factor from encoder ticks (or ticks/s, or ticks/s^2) as read from
  // the variable references above to radian (or radian/s, or radian/s^2).
  // Applied in the following way:
  //   radian_value = ticks_to_radian * variable_reference.
  double ticks_to_radian = 6;
}

// Describes device data for a drive following the CiA 402 (DS402) profile for
// drives and motion control.
message Ds402DeviceData {
  // Reference to the Status Word (Object 0x6041), which indicates the current
  // state of the drive's state machine.
  VariableReference status_word_reference = 1;
  // Reference to the Error Code (Object 0x603F), which provides specific error
  // information when the drive is in a fault state.
  VariableReference error_code_reference = 2;

  // Reference to the Control Word (Object 0x6040), which is used to command
  // transitions in the drive's state machine.
  VariableReference control_word_reference = 3;

  // Reference to Digital Outputs (Object 0x60FE).
  optional VariableReference digital_outputs_reference = 4;

  // Configuration for DS402 homing.
  // If not provided, homing support is disabled for this drive.
  optional HomingReference homing_reference = 5;
}

// Configuration for DS402 homing variables.
message HomingReference {
  oneof configuration {
    // NOTE: This is not implemented yet and will return an error if selected.
    // Automatically resolve all standard DS402 homing variables (0x6098,
    // 0x607C, etc.). The engine will prefer PDOs if they exist, otherwise it
    // will fallback to SDOs.
    Auto auto = 1;

    // Manually specify which variables to use for homing.
    Manual manual = 2;

    // Explicitly disable homing support for this device.
    Disabled disabled = 3;
  }

  message Auto {}

  message Disabled {}

  // Manual mapping of variables used for homing.
  // If a variable is provided here, it will be resolved by the device service
  // and integrated into the PDO configuration.
  // Unset variables will be accessed via SDO by the hardware module. This might
  // fail for variables that are already available as PDO.
  message Manual {
    // Object 0x6098: Homing method
    optional VariableReference homing_method = 1;
    // Object 0x607C: Home offset
    optional VariableReference home_offset = 2;
    // Object 0x6099.1: Homing speed (Switch/Zero)
    optional VariableReference homing_speed = 3;
    // Object 0x6099.2: Homing speed (Creep)
    optional VariableReference homing_creep_speed = 4;
    // Object 0x609A: Homing acceleration
    optional VariableReference homing_acceleration = 5;
    // Object 0x6060: Modes of operation
    optional VariableReference modes_of_operation = 6;
    // Object 0x6061: Modes of operation display
    optional VariableReference modes_of_operation_display = 7;
  }
}

// Represents a variable (object) within an EtherCAT device.
// This structure allows users to define variables using names or
// precise hardware addresses.
message VariableReference {
  // The PDO (Process Data Object) that contains or should contain the variable.
  // This is optional. If omitted, the engine will search all active PDOs
  // for the object.
  //
  // Options:
  // 1. Numerical Index: Use hex or decimal (e.g., "0x1A01", "#x1A01", "6657").
  //    This is the most stable and unambiguous method.
  // 2. Exact Name: The string name of the PDO as it appears in the ESI file
  //    (e.g., "2nd Transmit PDO mapping").
  string pdo = 1;

  // The specific object within the device's Object Dictionary.
  //
  // Options:
  // 1. Strict Address: "Index.SubIndex" using hex or decimal
  //    (e.g., "0x603F.0", "#x603F.0", "24639.0", "0x603F.0x0").
  //    *Priority:* If the string follows numerical notation AND the
  //    address exists in the hardware, it is resolved as an address.
  // 2. Exact Name: The string name of the variable from the ESI
  //    (e.g., "Error code", "Status word").
  //
  // Ambiguity Handling:
  // If a string could be both a valid address and a valid name, the engine
  // will prioritize the Address. If the user intends to target a Name that
  // happens to look like an address (e.g., a variable named "100"), they
  // must use the "name:" prefix (e.g., "name:100").
  string object = 2;
}
