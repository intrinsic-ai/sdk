// Copyright 2023 Intrinsic Innovation LLC

#ifndef INTRINSIC_ICON_CONTROL_C_API_WRAPPERS_STREAMING_IO_WRAPPER_H_
#define INTRINSIC_ICON_CONTROL_C_API_WRAPPERS_STREAMING_IO_WRAPPER_H_

#include <any>
#include <functional>
#include <type_traits>
#include <utility>

#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/string_view.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/message.h"
#include "intrinsic/icon/control/c_api/c_action_factory_context.h"
#include "intrinsic/icon/control/c_api/convert_c_realtime_status.h"
#include "intrinsic/icon/control/c_api/wrappers/string_wrapper.h"
#include "intrinsic/icon/utils/realtime_status.h"
#include "intrinsic/icon/utils/realtime_status_or.h"

namespace intrinsic::icon {
namespace internal {

// Casts `self` to `T`, then deletes it.
//
// This makes the code below a bit more concise, since the streaming IO
// parser/converter functions need destroy function pointers for user-supplied
// template parameter types.
template <typename T, typename CApiT>
void DestroyFn(CApiT* self) {
  if (self != nullptr) {
    delete reinterpret_cast<T*>(self);
  }
}

// Unwraps and then invokes a streaming input parser function.
//
// Don't call this directly. It's used in WrapStreamingInputParser() below, to
// safely associate the correct invoke function with each wrapped parser.
//
// 1. Attempts to parse `proto_input_string` into a `ProtoT` message,
//    aborting if that fails.
// 2. Casts `self` to
//    std::function<absl::StatusOr<RealtimeT>(const ProtoT& input)>
//    This is the inverse of the cast in WrapStreamingInputParser().
// 3. Invokes the parser function, aborting if there is an error.
// 4. Moves the parser's output into a heap-allocated `RealtimeT`.
// 5. Casts that `RealtimeT` pointer to `IntrinsicIconStreamingOutputType` to
// match
//    the C API.
//
// NOTE: Ownership of the return value passes to the caller, who *must* destroy
//       it (*not* in a realtime thread!). The corresponding
//       IntrinsicIconStreamingInputParserFnInstance holds a matching
//       `destroy_input` function.
template <class ProtoT, typename RealtimeT,
          typename = std::enable_if_t<
              std::is_base_of_v<::google::protobuf::Message, ProtoT>>>
IntrinsicIconStreamingInputType* InvokeParser(
    IntrinsicIconStreamingInputParserFn* self,
    IntrinsicIconStringView proto_input_string,
    IntrinsicIconRealtimeStatus* status_out) {
  google::protobuf::Any any_input;
  if (!any_input.ParseFromArray(proto_input_string.data,
                                proto_input_string.size)) {
    *status_out = FromRealtimeStatus(
        icon::InternalError("Failed to parse streaming input proto."));
    return nullptr;
  }
  ProtoT proto_input;
  any_input.UnpackTo(&proto_input);
  absl::StatusOr<RealtimeT> result =
      (*reinterpret_cast<
          std::function<absl::StatusOr<RealtimeT>(const ProtoT& input)>*>(
          self))(proto_input);
  if (!result.ok()) {
    *status_out = FromAbslStatus(result.status());
    return nullptr;
  }
  *status_out = FromAbslStatus(absl::OkStatus());
  return reinterpret_cast<IntrinsicIconStreamingInputType*>(
      new std::any(std::move(*result)));
}

// Unwraps and then invokes a streaming output converter function.
//
// Don't call this directly. It's used in WrapStreamingOutputConverter() below,
// to safely associate the correct invoke function with each wrapped parser.
//
// 1. Checks `realtime_output_size` against the size of `RealtimeT`, returning
//    an error if the sizes do not match.
// 2. Casts `realtime_output_buffer` to `RealtimeT`
// 3. Casts `self` to
//    std::function<absl::StatusOr<ProtoT>(const RealtimeT& output)>
//    This is the inverse of the cast in WrapStreamingOutputConverter().
// 4. Invokes the converter function, aborting if there is an error
// 5. Serializes the `ProtoT` generated by the converter into a string, and
//    returns that as an IntrinsicIconString pointer.
//
// NOTE: Ownership of the returned string passes to the caller, who *must*
//       destroy it (*not* in a realtime thread!). The corresponding
//       IntrinsicIconStreamingOutputConverterFnInstance holds a matching
//       `destroy_string` function.
template <class RealtimeT,
          typename = std::enable_if_t<std::is_trivially_copyable_v<RealtimeT>>>
IntrinsicIconString* InvokeConverter(
    IntrinsicIconStreamingOutputConverterFn* self,
    const IntrinsicIconStreamingOutputType* realtime_output_buffer,
    const size_t realtime_output_size,
    IntrinsicIconRealtimeStatus* result_status_out) {
  if (sizeof(RealtimeT) != realtime_output_size) {
    *result_status_out =
        FromRealtimeStatus(icon::InternalError(icon::RealtimeStatus::StrCat(
            "Realtime output size is ", realtime_output_size,
            ", but expected output type's size is ", sizeof(RealtimeT), ".")));
    return nullptr;
  }
  const auto* realtime_output =
      reinterpret_cast<const RealtimeT*>(realtime_output_buffer);
  auto result =
      (*reinterpret_cast<std::function<absl::StatusOr<google::protobuf::Any>(
           const RealtimeT& output)>*>(self))(*realtime_output);
  *result_status_out = FromAbslStatus(result.status());
  if (!result.ok()) {
    return nullptr;
  }
  return Wrap(result->SerializeAsString());
}
}  // namespace internal

// Wraps `parser` for use with the ICON C API.
//
// Caller assumes ownership of the `self` pointer, and is responsible for
// calling `destroy` on it (or passing on ownership).
template <typename ProtoT, typename RealtimeT,
          typename = std::enable_if_t<
              std::is_base_of_v<::google::protobuf::Message, ProtoT>>>
IntrinsicIconStreamingInputParserFnInstance WrapStreamingInputParser(
    std::function<absl::StatusOr<RealtimeT>(const ProtoT& input)> parser) {
  return IntrinsicIconStreamingInputParserFnInstance{
      .self = reinterpret_cast<IntrinsicIconStreamingInputParserFn*>(
          new std::function<absl::StatusOr<RealtimeT>(const ProtoT& input)>(
              std::move(parser))),
      .invoke = internal::InvokeParser<ProtoT, RealtimeT>,
      .destroy = internal::DestroyFn<
          std::function<absl::StatusOr<RealtimeT>(const ProtoT& input)>,
          IntrinsicIconStreamingInputParserFn>,
      .destroy_input =
          internal::DestroyFn<std::any, IntrinsicIconStreamingInputType>,
  };
}

// Unwraps a streaming input value.
//
// Returns nullptr if `input_wrapped` is nullptr.
// Returns FailedPreconditionError if `input_wrapped` is non-null and points to
// a std::any, but the type within is not `RealtimeT`.
template <typename RealtimeT>
RealtimeStatusOr<const RealtimeT*> UnwrapStreamingInput(
    const IntrinsicIconStreamingInputType* input_wrapped) {
  if (input_wrapped == nullptr) return nullptr;
  auto* any_input = reinterpret_cast<const std::any*>(input_wrapped);
  const RealtimeT* input = std::any_cast<RealtimeT>(any_input);
  if (input == nullptr) {
    return FailedPreconditionError(
        "Streaming input value does not have expected type.");
  }
  return input;
}

// Wraps `converter` for use with the ICON C API.
//
// Caller assumes ownership of the `self` pointer, and is responsible for
// calling `destroy` on it (or passing on ownership).
template <typename RealtimeT, typename ProtoT,
          typename = std::enable_if_t<
              std::is_base_of_v<::google::protobuf::Message, ProtoT>>,
          typename = std::enable_if_t<std::is_trivially_copyable_v<RealtimeT>>>
IntrinsicIconStreamingOutputConverterFnInstance WrapStreamingOutputConverter(
    std::function<absl::StatusOr<ProtoT>(const RealtimeT& output)> converter) {
  return IntrinsicIconStreamingOutputConverterFnInstance{
      .self = reinterpret_cast<IntrinsicIconStreamingOutputConverterFn*>(
          new std::function<absl::StatusOr<google::protobuf::Any>(
              const RealtimeT& output)>(
              std::move(
                  [converter = std::move(converter)](const RealtimeT& output)
                      -> absl::StatusOr<google::protobuf::Any> {
                    auto result = converter(output);
                    if (!result.ok()) {
                      return result.status();
                    }
                    google::protobuf::Any output_any;
                    output_any.PackFrom(result.value());
                    return output_any;
                  }))),
      .destroy_string = DestroyString,
      .invoke = internal::InvokeConverter<RealtimeT>,
      .destroy = internal::DestroyFn<
          std::function<absl::StatusOr<google::protobuf::Any>(
              const RealtimeT& output)>,
          IntrinsicIconStreamingOutputConverterFn>,
  };
}

}  // namespace intrinsic::icon

#endif  // INTRINSIC_ICON_CONTROL_C_API_WRAPPERS_STREAMING_IO_WRAPPER_H_
